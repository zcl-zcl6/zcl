---
title: "R的内部机制"
output: 
  html_document: 
    fig_caption: yes #fig_caption 控制是否使用标题呈现数字
    highlight: haddock #highlight指定语法高亮样式
    keep_md: yes #在渲染后保留Markdown文件的副本
    number_sections: yes #number_sections选项将标题编号添加到标题
    theme: united #theme指定用于页面的Bootstrap主题（主题来自Bootswatch主题库）
    toc: yes #toc选项添加目录（TOC）
    toc_depth: 6 #用该选项指定它应用的标题深度toc_depth，默认为3（意味着所有级别1,2和3标头将包含在目录中）
    toc_float:  #指定将toc_float目录浮动到主文档内容左侧的选项，即使滚动文档，浮动目录也始终可见
      collapsed: false #collapsed（默认为TRUE）控制TOC是否仅显示顶级（例如H2）标题。如果最初崩溃，TOC会在必要时自动扩展内联
      smooth_scroll: false #smooth_scroll（默认为TRUE）控制在通过鼠标单击导航到TOC项目时是否为页面滚动设置动画
---



# 概述
  
  为了避免对一些意外结果感到混乱和困惑，更好地理解和运用这些函数，需要对R中的函数的运行方式有一个基本但具体的理解。在本章将学习以下内容：
  
  - 惰性求值（Lazy evaluation）
  - 复制-修改机制（Copy-on-modify mechanism）
  - 词法作用域（Lexical scoping）
  - 环境（Environment）
  
# 惰性求值（按需计算）


```r
test0 <- function(x, y){
  if(x > 0) x else y
}
```
  
  上面这个函数只有在x不大于0时，才需要y值。如果把一个正值赋值给x而忽略y，这个函数会因为没有为所有定义的参数赋值而报错么？
  

```r
test0(1)
```

```
## [1] 1
```

```r
# test0(-1)
# Error in test0(-1) : 缺少参数"y",也没有缺省值
```
  
  以上结果说明，当x赋值一个正数的时候，即使没有y值，也不会报错。即调用函数的时候，只需要对必需的参数进行赋值既可。当x赋值为复数时，函数便需要y值，此时由于没有给y值赋值，才会报错。
  
  如果非要指定在函数中没有用到的参数，那么，程序会在调用之前计算它们，还是根本不会计算呢？
  

```r
test0(1, stop("Stop now"))
```

```
## [1] 1
```

```r
# test0(-1, stop("Stop now"))
# Error in test0(-1, stop("Stop now")) : Stop now
```
  
  以上函数说明，只有需要的时候，参数才会被计算。这个机制被称为惰性求值，即按需计算。
  
  惰性求值的优点： 节省时间，避免了不必要的计算；他允许对函数参数默认值进行更灵活的说明，例如可以在一个参数的表达式中使用另一个参数：
  

```r
test2 <- function(x, n = floor(length(x) / 2)){
  x[1:n]
}
test2(1:10)
```

```
## [1] 1 2 3 4 5
```

```r
test2(1:10, 3)
```

```
## [1] 1 2 3
```

  在调用test2函数时，若不指定n，则默认取第一个参数长度的一半；同时也可以无视n的默认值，通过参数指定。
  
  惰性求值是一把双刃剑，有利有弊。在调用函数时，其参数只被解析不被计算，所以我们只能确定参数表达式在语法上是正确的，但难以确定它的有效性。
  
  如以下实例，当test2函数在编写过程中将n的表达式中的x误写成未定义的变量w：
  

```r
test3 <- function(x, n = floor(length(w) / 2)){
  x[1:n]
}
```
  
  在函数创建过程中不会报错，只有在调用的时候才会报错：
  

```r
# test3(1:10)
# Error in test3(1:10) : 找不到对象'w'
```
  
  但是若在调用test3之前，定义了w，则会产生意想不到的结果：
  

```r
w <- c(1, 2, 3)
test3(1:10)
```

```
## [1] 1
```
  
  这个例子更清晰地说明惰性求值：
  

```r
test4 <- function(x, y = p){
  p <- x + 1
  c(x, y)
}
test4(3)
```

```
## [1] 3 4
```
  
  惰性求值的一个巧妙的用法：
  

```r
check_input <- function(x){
  switch(x,
         y = message("yes"),
         n = message("no"),
         stop("Invalid input"))
}
check_input("y")
```

```
## yes
```

```r
check_input("n")
```

```
## no
```

```r
# check_input("a")
# Error in check_input("a") : Invalid input
```
  
  **惰性求值使得，不能过度依赖解析器检查代码，解析器只能检查出语法错误，无法检查出逻辑错误。**
  
# 复制-修改机制

  本节介绍R的一个重要的特性，以便更安全地处理数据。tracemem()函数用来追踪内存中数据的足迹。

## 一个对象有多个名称时的复制-修改机制
  

```r
x1 <- c(1, 2, 3) #新建一个变量
x2 <- x1 #将x1的值赋给x2
x1[1] <- 0
x1
```

```
## [1] 0 2 3
```

```r
x2
```

```
## [1] 1 2 3
```
  
  可以看到，当把x1赋值给x2后，修改x1的值，x2的值并不会发生变化。即此时x1和x2的内存地址不一样。那么是什么时候发生数据复制，内存地址的改变呢？
  

```r
x1 <- c(1, 2, 3) #新建一个变量
x2 <- x1 #将x1的值赋给x2
tracemem(x1)
```

```
## [1] "<00000000181ADEA0>"
```

```r
tracemem(x2)
```

```
## [1] "<00000000181ADEA0>"
```

```r
x1[1] <- 0
```

```
## tracemem[0x00000000181adea0 -> 0x0000000018303280]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous>
```

```r
tracemem(x1)
```

```
## [1] "<0000000018303280>"
```

```r
tracemem(x2)
```

```
## [1] "<00000000181ADEA0>"
```

  可以看到，当把x1赋值给x2时，x1的内存地址发生改变。即当多个变量指向同一对象的时候，那么修改任何一个变量都会生成新对象的一个副本。

## 函数参数的复制-修改机制

  修改函数参数是另一种引发复制-修改机制的情况。如下：
  

```r
modify_first <- function(x){
  x[1] <- 0
  x
}
v1 <- c(1, 2, 3)
modify_first(v1)
```

```
## [1] 0 2 3
```

```r
v1
```

```
## [1] 1 2 3
```

```r
v2 <- list(x = 1, y = 2)
modify_first(v2)
```

```
## $x
## [1] 0
## 
## $y
## [1] 2
```

```r
v2
```

```
## $x
## [1] 1
## 
## $y
## [1] 2
```

  以上两个例子中，函数都只返回了原始对象修改后的数据，但是并没有改变原始对象。但是，直接在函数外部修改向量就会改变原始对象。
  

```r
v1[1] <- 0
v1
```

```
## [1] 0 2 3
```

```r
v2[1] <- 0
v2
```

```
## $x
## [1] 0
## 
## $y
## [1] 2
```
  
  若要使用修改后的数据，就需要将其赋值给原始变量。
  

```r
v3 <- 1:5
v3 <- modify_first(v3)
v3
```

```
## [1] 0 2 3 4 5
```
  
  这几个例子表明，修改函数的参数也会生成一个副本以确保函数外部对象不受影响。
  
  此外，修改对象属性也会触发复制-修改机制
  
## 修改函数外部的对象

  尽管存在复制-修改机制，我们仍可以用运算符<<- 修改函数外部的向量。例如我们有一个变量x，然后创建一个函数modify_x将一个新值赋给变量x:
  

```r
x <- 0
modify_x <- function(value){
  x <<- value
}
modify_x(3)
x
```

```
## [1] 3
```
  
 若想将一个向量映射到一个新的列表上，同时做一些计算，这个方法就很有用。以下代码创建了一个由元素数目递增的向量构成的列表，在lapply的每一次迭代中，我们用count函数计算生成向量的元素数目的总和：
 

```r
count <- 0
lapply(1:3, function(x){
  result <- 1:x
  count <<- count + length(result)
  result
})
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1 2
## 
## [[3]]
## [1] 1 2 3
```

```r
count
```

```
## [1] 6
```
 
  运算符<<-的另一个用法是“拉平”一个嵌套列表。假设我们有如下嵌套列表：
  

```r
nested_list <- list(
  a = c(1, 2, 3),
  b = list(
    x = c("a", "b", "c"),
    y = list(
      z = c(TRUE, FALSE),
      w = c(2, 3, 4)
    )
  )
)
str(nested_list)
```

```
## List of 2
##  $ a: num [1:3] 1 2 3
##  $ b:List of 2
##   ..$ x: chr [1:3] "a" "b" "c"
##   ..$ y:List of 2
##   .. ..$ z: logi [1:2] TRUE FALSE
##   .. ..$ w: num [1:3] 2 3 4
```
  
  我们想要把这个列表“拉平”，即将所有嵌套的部分放在最外层。以下代码使用rapply函数和<<-实现这个结果。
  
  首先，rapply是lapply的递归版本。每次迭代中，函数都作用在列表的特定层的原子向量上，直到遍历所有层的所有原子向量。
  rapply(nested_list,f)的主要运行方式是：
  
  f(c(1, 2, 3))
  f(c("a", "b", "c"))
  f(c(TRUE, FALSE))
  f(c(2, 3, 4))
  

```r
flat_list <- list()
i <- 1
res <- rapply(nested_list, function(x){
  flat_list[[i]] <<- x
  i <<- i + 1
})
res
```

```
##     a   b.x b.y.z b.y.w 
##     2     3     4     5
```

```r
flat_list
```

```
## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] "a" "b" "c"
## 
## [[3]]
## [1]  TRUE FALSE
## 
## [[4]]
## [1] 2 3 4
```

  res中迭代次数的结果，即i<<- i + 1表达式最终i的值，并不那么重要。而res中的列名却表明了flat_list中每个元素的原始层级和名称。因此将res的元素名称赋给flat_list，以标示每个元素的原始层级：
  

```r
names(flat_list) <- names(res)
str(flat_list)
```

```
## List of 4
##  $ a    : num [1:3] 1 2 3
##  $ b.x  : chr [1:3] "a" "b" "c"
##  $ b.y.z: logi [1:2] TRUE FALSE
##  $ b.y.w: num [1:3] 2 3 4
```
  
# 词法作用域

  当在函数内部找不到值时，就会在自己被定义的地方而不是被调用的地方搜索，这个机制被称为词法作用域。这个规则也适用于<<-寻找变量的机理。
  
# 环境的工作方式

   本节通过创建和操作对象来了解它的行为，以及查看它的结构如何决定R函数的运行。
   
## 环境对象

  环境是由一组名称组成的对象，每个环境（除了空环境）都有一个父环境。每个名称（也称为符号或变量）都指向一个对象。当我们查找一个符号时，如果他在当前环境中，R就会在当前环境中搜索并返回该符号指向的对象。如果这个符号在当前环境中没有找到，R就会到他的父环境中搜索（直到找遍所有环境）。
  
## 创建并链接环境
 
   使用new.env()函数创建一个新环境：环境通常用十六进制数表示，即内存地址。


```r
e1 <- new.env()
e1
```

```
## <environment: 0x0000000017862488>
```
      
   我们可以用提取操作符（$和[[]]）在环境中创建变量，其代码形式类似于修改一个列表：
   

```r
e1$x <- 1
e1[["x"]]
```

```
## [1] 1
```
   
   但是，环境和列表有以下三大主要区别：
   
   - 环境没有索引；
   - 环境有父环境；
   - 环境具有引用语义。

### 访问环境

   环境没有索引，这说明我们既不能对环境构建子集，也不能通索引来从环境中提取元素。
   
   从环境中提取变量：
   
   - 直接输入对象名称和环境访问函数。如exists()函数：
   

```r
exists("x", e1) # 判断是否存在
```

```
## [1] TRUE
```

```r
exists("y", e1)
```

```
## [1] FALSE
```

```r
get("x", e1) # 获取值
```

```
## [1] 1
```

```r
e1$x
```

```
## [1] 1
```

```r
ls(e1) # 差看环境中的所有变量
```

```
## [1] "x"
```
   
  使用$或[[]]访问变量时，如果访问一个不存在的变量，则返回NULL。但如果使用get函数访问时，会报错。
  
## 链接环境

  环境有父环境，如果一个符号不存在于环境中，R就会到它的父环境中查找。假设我们对环境中的一个变量使用get函数。如果在此环境中找到变量，则获取其值，否则函数将会在父环境中查找变量。
  
  创建一个新的环境，令e1为e2的父环境：
  

```r
e2 <- new.env(parent = e1)
e1
```

```
## <environment: 0x0000000017862488>
```

```r
e2
```

```
## <environment: 0x000000001817de88>
```

```r
parent.env(e2)  # 取e2的父环境地址
```

```
## <environment: 0x0000000017862488>
```

```r
e2$y <- 2 # e2中新建一个变量
ls(e2) # 查看e2环境中的所有变量
```

```
## [1] "y"
```

```r
e2$y  # 提取y变量的三种方法
```

```
## [1] 2
```

```r
e2[["y"]]
```

```
## [1] 2
```

```r
exists("y", e2)
```

```
## [1] TRUE
```

```r
get("y", e2)
```

```
## [1] 2
```
  
  然而，提取操作符（$和[[]]）和环境访问函数有明显的区别。操作符只在单个环境域内库可用，而环境访问函数在一个环境链上都可用。
  

```r
e2$x
```

```
## NULL
```

```r
e2[["x"]]
```

```
## NULL
```

```r
exists("x", e2)
```

```
## [1] TRUE
```

```r
get("x", e2)
```

```
## [1] 1
```

```r
exists("x", e2, inherits = F) # 设置不在父环境中搜索
```

```
## [1] FALSE
```
  
  环境可以有很多层。
  
### 在引用语义下使用环境

  环境具有引用语义。这意味着，与原子向量和列表等数据类型不同。修改环境时不会复制该环境。
  
  例如：将e1的值赋给另一个变量e3：
  

```r
ls(e1)
```

```
## [1] "x"
```

```r
e3 <- e1
```
  
  如果有两个变量指向同一个列表，修改其中一个变量，首先会创建一个列表的副本，然后修改这个副本，而不影响原始列表。引用语义则不同。当通过任何一个变量修改环境时，都不会创建副本。
  

```r
ls(e1)
```

```
## [1] "x"
```

```r
e3$y <- 3
e1$y
```

```
## [1] 3
```

```r
ls(e1)
```

```
## [1] "x" "y"
```
  
  将一个环境作为参数传递给一个函数是也不会创建副本。
  
### 内置环境

  环境是R中的一种特殊类型的对象，但是从实现函数调用到词法作用域机制，无一不是基于环境实现的。事实上，一段R代码运行就是在一个环境中进行的。environment()函数可以查看当前在哪个环境中运行代码:
  

```r
environment()
```

```
## <environment: R_GlobalEnv>
```
  
   以上结果是指当前环境为全局环境。事实上，每次新开启一个可以供用户输入的R会话，其工作环境都是全局环境。在做数据分析时，我们通常都是在这个环境中创建变量和函数的。
   
   访问全局环境的方法：1. 直接运行； 2： globalenv()和.GlobalEnv:
   
   全局环境是用户的工作空间；而基础环境baseenv（）则提供基础函数和运算符。全局环境和基础环境是最重要的内置环境。
   
   使用以下函数可以找出给定环境的环境链：
   

```r
parents <- function(env){
  while(T){
    nmae <- environmentName(env)
    # txt <- if(nzchar(name)) name else format(env)
    cat(nmae, "\n")
    env <- parent.env(env)
  }
}
# parents(globalenv())
# R_GlobalEnv 
# tools:rstudio 
# package:stats 
# package:graphics 
# package:grDevices 
# package:utils 
# package:datasets 
# package:methods 
# Autoloads 
# base 
# R_EmptyEnv 
```
 
## 与函数相关的环境

  有3个与函数及其运行过程相关的重要环境：执行环境，封闭环境，调用环境。
  
  每次调用函数时，R都会创建一个新的环境来主管函数的执行过程，这就是函数调用的执行环境。 函数的参数和函数中创建的变量实际上是执行环境中的变量。
  
  函数的执行环境也有父环境，即函数的封闭环境，即定义函数的环境。这意味着函数在执行期间，任何未定义的变量都会到封闭环境中查找，这正是词法作用域的机理。
  
  调用环境即调用函数的环境，可以使用parent.frame()来获取当前执行函数的调用环境。
   
