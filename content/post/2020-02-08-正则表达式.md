---
title: 正则表达式
author: zcl
date: '2020-02-08'
slug: 正则表达式
categories: []
tags: []
---

# 正则表达式

  使用正则表达式解决问题需要两步：<br/>
      
      1. 寻找匹配文本的一个模式；
      2. 根据模式进行分组提取信息。

## 寻找字符串模式
  
  - 元符号
  
  符号| 含义
  :-:|:-
  ^|表示一行的开始
  \\w|表示一个字母
  \\s|表示一个空格
  \\d|表示一个数字字符
  $| 表示一行的结束
  [0-9]|表示0-9的单个整数
  [a-z]|表示a-z的单个小写字母
  [A-Z]|表示A-Z的单个大写字母
  .|表示任何符号
  *|表示一个模式出现零次，一次或多次
  +|表示一个模式至少出现一次
  {n}|表示一个模式重复出现n次
  {m,n}|表示一个模式至少出现m次，至多出现n次
  

```r
fruits <- readLines("data/fruits.txt") 
```

```
## Warning in readLines("data/fruits.txt"): 读'data/fruits.txt'时最后一行未遂
```

```r
fruits
```

```
## [1] "apple: 20"                 "orange: missing"          
## [3] "banana: 30"                "pear: sent to Jerry"      
## [5] "watermelon: 2"             "blueberry: 12"            
## [7] "strawberry: sent to James"
```

```r
matches <- grep("^\\w+:\\s\\d+$",fruits)
# 注： \\是对\ 的转义 
matches
```

```
## [1] 1 3 5 6
```

```r
fruits[matches]
```

```
## [1] "apple: 20"     "banana: 30"    "watermelon: 2" "blueberry: 12"
```
  
   以上是以^开始，以$结束，是完全匹配；还可以部分匹配：

```r
grep("\\d", c("a", "a12", "12b", "123", "1"))
```

```
## [1] 2 3 4 5
```
  
## 使用分组提取数据

 使用括号对想要从文本中提取的部分做标记：

```r
library("stringr")
matches <- str_match(fruits, "^(\\w+):\\s(\\d+)$")
matches
```

```
##      [,1]            [,2]         [,3]
## [1,] "apple: 20"     "apple"      "20"
## [2,] NA              NA           NA  
## [3,] "banana: 30"    "banana"     "30"
## [4,] NA              NA           NA  
## [5,] "watermelon: 2" "watermelon" "2" 
## [6,] "blueberry: 12" "blueberry"  "12"
## [7,] NA              NA           NA
```


```r
telephone <- c("123-4567", "123-4568", "1234-5678", "1234-5679", "123456")
telephone[grep("^\\d{3}-\\d{4}$", telephone)]
```

```
## [1] "123-4567" "123-4568"
```

```r
telephone[grep("^\\d{3,4}-\\d{3,4}$", telephone)]
```

```
## [1] "123-4567"  "123-4568"  "1234-5678" "1234-5679"
```

 - 找出异常情况，grepl() 返回一个逻辑向量，指每个元素是否匹配